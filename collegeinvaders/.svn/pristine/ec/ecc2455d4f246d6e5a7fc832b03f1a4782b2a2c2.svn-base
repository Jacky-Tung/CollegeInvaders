//Create the game scene
class GameScene extends Phaser.Scene {
  constructor() {
    super({ key: "GameScene" }); //create keyword
  }

  //load all contents
  preload() {
    this.load.image("background", "assets/images/grassBackground.png");
    this.load.image("player", "assets/images/humanoid.png");
    this.load.image("playerLeft", "assets/images/humanoidleft.png");
    this.load.image("playerRight", "assets/images/humanoidright.png");
    this.load.image("bullet", "assets/images/Bullet.png");
    this.bulletSize = 0.1; //sets player bullet size.
    this.load.image("playerThrow", "assets/images/humanoidthrow.png");
    this.load.image("admin", "assets/images/admin.png");
    this.load.image("adminLeft", "assets/images/admin_left.png");
    this.load.image("adminRight", "assets/images/admin_right.png");
    this.load.image("adminThrow", "assets/images/admin_throw.png");
    this.load.image("adminBullet", "assets/images/admin_bullet.png");
    this.load.image("pause", "assets/images/pause_button.png");
    this.load.image("play", "assets/images/play_button.png");
    this.load.image("trustee", "assets/images/trustee.png");
    this.load.image("trusteeLeft", "assets/images/trustee_left.png");
    this.load.image("trusteeRight", "assets/images/trustee_right.png");
  }

  //create all components for the game screen
  create() {
    var time = this.time;
    // create a sprite for the background image
    var backgroundImage = this.add.image(0, 0, "background");
    backgroundImage.setOrigin(0, 0);
    backgroundImage.setScale(2);

    // create player
    playerSprite = new Player(this, 335, 760, playerSize);
    this.add.existing(playerSprite); // add player to the game world

    trusteeSprite = new Trustee(this, 0, 57, "towardsRight");

    this.add.existing(trusteeSprite);

    // create enemySprites group
    createAdminSprites.call(this);

    adminBullets = this.physics.add.group();

    //Create game texts
    this.scoreText = this.add.text(450, 16, "Score:" + score, {
      fontSize: "18px",
      fill: "#FFF",
    });
    this.livesText = this.add.text(550, 16, "Lives:" + lives, {
      fontSize: "18px",
      fill: "#FFF",
    });

    //load pausebutton image
    const pauseButton = this.add.image(16, 16, "pause");
    pauseButton.setScale(0.5);
    pauseButton.setInteractive();
    pauseButton.on("pointerdown", () => {
      this.pauseGame();
    });

    // timer to control the firing of admin enemy
    const adminTimer = this.time.addEvent({
      delay: 1000,
      loop: true,
      callback: () => {
        const randomAdminIndex = Phaser.Math.Between(
          0,
          adminSprites.getChildren().length - 1
        );
        const randomAdmin = adminSprites.getChildren()[randomAdminIndex];

        // fire admin bullets when there are admins and add each bullet fired to adminBullets group for collision
        if (adminSprites.getChildren().length !== 0) {
          randomAdmin.adminFire();
        }
      },
    });

    /**
     * collision detection between player bullets and admin enemies
     * issue of collision detected during start of game (active player bullets)
     *  */
    adminSprites.children.iterate(function (enemy){
      enemy.body.onOverlap = true;
    });

    this.physics.add.overlap(
      playerSprite.bullets,
      adminSprites
    );

    this.physics.world.on('overlap', playerHitAdmin);

    /**
     * collision detection between admin bullets and player
     * issue of admin bullets not moving after being fired 
     */
    // this.physics.add.overlap(adminBullets, playerSprite, (adminBullet) => {
    //   adminBullet.destroy();
    //   lives--;
    // });
  }

  update(time) {
    playerSprite.update(time);
    trusteeSprite.update(time);
    // let numEnemiesToFire = Math.floor(
    //   Math.random() * (adminSprites.children.size / 4)
    // ); // Chooses a random number as limit for the number of enemies to fire. Divide by 2 to make more enemies shoot.
    // let enemiesFired = 0;
    // add enemy movement and firing here if needed
    // update each enemy
    adminSprites.children.iterate(function (enemy, index) {
      // if (enemiesFired < numEnemiesToFire && Math.random() < 0.5) {
      //   // randomly choose if this enemy should fire
      //   // enemy.adminFire();
      //   enemiesFired++;
      // }
      enemy.update();
      // descending enemies in unison after shifting directions
      if (
        (enemy.body.blocked.left && !enemy.body.blocked.right) ||
        (!enemy.body.blocked.left && enemy.body.blocked.right)
      ) {
        adminSprites.children.iterate(function (enemy) {
          enemy.descend();
        });
      }
    });
    
    // spawn admin when all destroyed 
    if (adminSprites.getChildren().length === 0) {
      createAdminSprites.call(this);
    }

    /**
     *  collision detection between admin bullets and player 
     *  very unefficient: collision detection is created for each admin's individual group of bullets
     *  current optimization is only if statement
     */
    adminSprites.children.iterate((admin) => {
      if(admin.enemyBullets.getChildren().length !== 0){
        this.physics.add.overlap(
          admin.enemyBullets,
          playerSprite,
          adminHitPlayer
        );
      }
    });

    this.livesText.setText("Lives:" + lives);
  }

  //pauseGame function stops current scene and runs the pause screen
  pauseGame() {
    this.scene.pause("GameScene");
    this.scene.run("PauseScene");
  }
}

// game entities
var playerSprite;
var playerBullets;
var playerBulletSpeed = -400;
var playerSize = 0.65;
var adminSprites;
var adminBullets;
var adminBulletSpeed = 200;
var adminSize = 0.5;
var lastFired = 0;
var adminLastFired = 0;
var score = 0;
var lives = 3;
var gameStart = false;
var gamePaused = false;
var adminDirection = "";
var trusteeSprite;

// components
var keyListener;

//Bullet class
class Bullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, bulletKey) {
    super(scene, x, y, bulletKey);
  }

  fire(x, y, yVelocity, bulletPosition) {
    this.body.reset(x, y);
    this.setActive(true);
    this.setVisible(true);
    this.setScale(this.scene.bulletSize);
    this.setPosition(x, bulletPosition);
    this.setVelocityY(yVelocity);
  }

  preUpdate(time, delta) {
    super.preUpdate(time, delta);

    if (this.y <= -32) {
      this.setActive(false);
      this.setVisible(false);
    }
  }
}

//Bullets class
class Bullets extends Phaser.Physics.Arcade.Group {
  constructor(scene, bulletKey) {
    super(scene.physics.world, scene);

    this.createMultiple({
      classType: Bullet,
      frameQuantity: 60,
      active: false,
      visible: false,
      key: bulletKey,
    });

    this.setDepth(1);
  }

  fireBullet(x, y, velocity, bulletPosition) {
    let bullet = this.getFirstDead(false);

    if (bullet) {
      bullet.fire(x, y, velocity, bulletPosition);
    }
  }
}

//Player class
class Player extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, size) {
    super(scene, x, y, "player");
    scene.add.existing(this);
    scene.physics.world.enable(this);
    this.keyListener = scene.input.keyboard.createCursorKeys();
    this.setScale(size);
    this.setCollideWorldBounds(true);
    this.lastFired = 0;
    this.bullets = new Bullets(scene, "bullet");
  }

  update(time) {
    this.handleInput();
    this.handleFiring(time);
  }

  handleInput() {
    if (this.keyListener.left.isDown) {
      this.setTexture("playerLeft");
      this.setVelocityX(-250);
    } else if (this.keyListener.right.isDown) {
      this.setTexture("playerRight");
      this.setVelocityX(250);
    } else {
      this.setTexture("player");
      this.setVelocityX(0);
    }
  }

  handleFiring(time) {
    if (this.keyListener.space.isDown) {
      this.setTexture("playerThrow");
    }
    if (this.keyListener.space.isDown && time > this.lastFired) {
      this.bullets.fireBullet(this.x, this.y, playerBulletSpeed, this.y - 35); //negative 400 so bullets go upward. this.y-40, if y-positve = bullets fire above the head.
      this.lastFired = time + 200;
    }
  }
}

// Trustee class
class Trustee extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, direction) {
    super(scene, x, y, "trustee");
    scene.add.existing(this);
    scene.physics.world.enable(this);
    this.direction = direction;
    this.setScale(0.65);
  }

  moveLeft() {
    this.setVelocityX(-200);
    this.setTexture("trusteeLeft");
  }

  moveRight() {
    this.setVelocityX(200);
    this.setTexture("trusteeRight");
  }

  trusteeMovement() {
    if (this.direction === "towardsRight") {
      this.moveRight();
    } else if (this.direction === "towardsleft") {
      this.moveLeft();
    }
  }

  update() {
    this.trusteeMovement();
  }
}

//Enemy class.
class Admin extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) {
    super(scene, x, y, "admin");
    this.direction = 1;
    this.setDepth(1);
    this.setScale(adminSize);
    this.enemyLastFired = 0;
    this.enemyBullets = new Bullets(scene, "adminBullet");
  }

  moveRight() {
    this.setVelocityX(75);
    this.setTexture("adminRight");
  }

  moveLeft() {
    this.setVelocityX(-75);
    this.setTexture("adminLeft");
  }

  fireBullet() {
    this.setTexture("adminThrow");
    this.enemyBullets.fireBullet(
      this.x,
      this.y + 10,
      adminBulletSpeed,
      this.y + 40
    ); // 150 = enemy firing speed. this.y-40, if y-positve = bullets fire below the head.
    this.enemyBullets.children.iterate((child) => {
      //Iterates over all the enemyBullets.
      child.setScale(0.5); // set the scale to 0.5. Sets the size for enemy bullets.
    });
  }

  // controls how much the admin descends.
  descend() {
    this.y += 5;
  }

  //Controls enemy movement.
  adminMovement() {
    if (adminDirection === "right" && !this.body.blocked.right) {
      this.moveRight();
    } else if (adminDirection === "left" && !this.body.blocked.left) {
      this.moveLeft();
    }

    if (this.body.blocked.left) {
      this.moveRight();
      adminDirection = "right";
    } else if (this.body.blocked.right) {
      this.moveLeft();
      adminDirection = "left";
    }
  }

  //Controls whent the enemy fires. the 2000 value means every 2 seconds.
  adminFire() {
    if (this.scene.time.now > this.enemyLastFired + 2000) {
      this.fireBullet();
      this.enemyLastFired = game.getTime();
    }
  }
  update() {
    this.adminMovement();
  }
}

//Function spawns Admin enemies and positions enemies.
function createAdminSprites() {
  // create enemySprites group
  adminSprites = this.physics.add.group({
    classType: Admin,
    key: "admin",
    repeat: 54,
  });

  // position enemies in rows
  let enemyX = 100;
  let enemyY = 100;

  for (let i = 0; i < adminSprites.getChildren().length; i++) {
    const enemy = adminSprites.getChildren()[i];
    enemy.setScale(0.5);

    // set enemy position and movement
    enemy.setPosition(enemyX, enemyY);
    enemy.setVelocityX(100);
    enemy.setCollideWorldBounds(true);
    enemy.setBounce(1);

    // update position for next enemy
    enemyX += 50;
    if ((i + 1) % 11 === 0) {
      enemyX = 100;
      enemyY += 50;
    }
  }
}

// callback function for collision between player bullets and admin enemies
function playerHitAdmin(playerBullet, admin) {
  playerBullet.destroy();
  admin.destroy();
}

// callback function for collision between admin bullets and player
function adminHitPlayer(player, adminBullet){
  adminBullet.destroy();
  lives--;
}

import MainMenu from "./MainMenuScene.js";
//import GameScene from './GameScene.js';
import PauseScene from "./PauseScene.js";
import ConfirmationScene from "./ConfirmationScene.js";
// game configurations
const config = {
  type: Phaser.AUTO,
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: 650,
    height: 650,
  },
  physics: {
    default: "arcade",
    arcade: {
      gravity: { y: 0 },
    },
  },
  input: {
    mouse: true,
  },
  scene: [MainMenu, GameScene, PauseScene, ConfirmationScene],
};

// game variable
const game = new Phaser.Game(config);
export default game;
